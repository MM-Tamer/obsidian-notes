Some examples of DML statements

| Command      | Description                          | Syntax                                                                             |
| ------------ | ------------------------------------ | ---------------------------------------------------------------------------------- |
| INSERT       | Insert data into a table             | INSERT INTO _table_name_ (column1, column2, .....) VALUES (value1, value2, .....); |
| UPDATE       | Update existing data within a table  | UPDATE _table_name_ SET column1 = value1, column2 = value2 WHERE condition;        |
| DELETE       | Delete records from a database table | DELETE FROM _table_name_ WHERE condition;                                          |
| LOCK         | Lock table control concurrency       | LOCK TABLE _table_name_ IN lock_mode;                                              |
| CALL         | Call a PL/SQL or JAVA subprogram     | CALL procedure_name(arguments);                                                    |
| EXPLAIN PLAN | Describe the access path to data     | EXPLAIN PLAN FOR SELECT * FROM _table_name_;                                       |



> [!NOTE] INSERT
> You can use INSERT in multiple ways
```sql
-- mentioning attrubutes in their original order 
INSERT INTO jobs_copy (job_id, job_title, min_salary, max_salary)
VALUES('PR_MGR', 'Project Manager', 7000, 18000);

  
-- changing the order of attributes
INSERT INTO jobs_copy (job_title, min_salary, job_id, max_salary)
VALUES('Architect',6500,'ARCH',15000);

  
-- omitting the attributes however inserting the values in the same order as the attributes
INSERT INTO jobs_copy
VALUES('DATA_ENG','Data Engineer',8000,21000);

  
-- omitting attributes that accept nulls
INSERT INTO jobs_copy (job_id, job_title, min_salary)
VALUES('DATA_ARCH','Data Architecture',8000);

-- feeding values from another table. CAUTION: attribute properties must conform to each other
INSERT INTO employees_copy(first_name,last_name,email,hire_date,job_id)
SELECT first_name,last_name,email,hire_date,job_id FROM employees WHERE job_id = 'IT_PROG';


```


> [!warning] IDENTITY & INSERT ALL
> Auto increment ( GENERATED BY DEFAULT AS IDENTITY) doesn't work with INSERT ALL INTO as all the inserted rows will have the same value in the identity field and the auto increment feature will not work properly.


---

> [!NOTE] UPDATE
> UPDATE can be utilized in multiple ways as well
> 
```sql
-- with no condition. CAUTION: WILL UPDATE ALL ROWS
UPDATE employees_copy
SET salary = 500;


-- with a condition most widely used
UPDATE employees_copy
SET salary = 50000
WHERE job_id = 'IT_PROG';

  
-- updating multiple columns
UPDATE employees_copy
SET salary = 5, department_id = null
WHERE job_id = 'IT_PROG';


-- alternative to updating multiple columns
UPDATE EMPLOYEES_COPY 
SET (SALARY, COMMISSION_PCT) = (SELECT MAX(SALARY), MAX(COMMISSION_PCT) FROM EMPLOYEES)
WHERE JOB_ID = 'IT_PROG';
```
---
>[!info] IN operator
>The IN operator is used to compare one value with a set of values and checks whether it matches any one of them.
>```sql
>SELECT first_name, last_name, email 
>FROM EMPLOYEES
>WHERE employee_id in (50, 100, 150, 200);
>```

>[!info] BETWEEN operator
>The BETWEEN operator is used to check if a value is within a given range (inclusive).
>```sql
>SELECT * FROM employees WHERE hire_date BETWEEN '07-JUN-02' AND '29-JAN-08';
>```

>[!info] IS [NOT] NULL operator
>Since NULL is not value, the equality operator cannot be used and the IS or IS NOT is used instead
>```sql
>SELECT * FROM employees WHERE commission_pct IS NOT NULL;
>```


>[!info]- ORDER BY Clause and NULLS {FIRST | LAST}
>ORDER BY is used to sort the returned data from a select query.
>You can either sort it in ascending order (default) or descending order and specify if the nulls appear first or last using [NULLS {FIRST | LAST}]. The default behavior is that NULLS are considered to be the largest possible values.
>
>```sql
>select first_name, salary, commission_pct 
>from employees 
>order by commission_pct NULLS FIRST;
>
select first_name, salary, commission_pct
from employees 
order by commission_pct ASC NULLS FIRST;
>
select first_name, salary, commission_pct 
from employees 
order by commission_pct DESC;
>
>select first_name, salary, commission_pct 
>from employees 
>order by commission_pct DESC NULLS LAST;
>```


---
[[String Manipulation functions]]

---

> [!INFO]- Oracle Conditional + Expressions CASE Expressions
> Oracle case expressions is similar to the switch construct in programming  
>```sql
SELECT first_name,
>         last_name,
>         job_id,
>         salary,
>         CASE job_id
> 
>             WHEN 'ST_CLERK' THEN salary * 1.2
> 
>             WHEN 'SA_REP'   THEN salary * 1.3
> 
>             WHEN 'IT_PROG'  THEN salary * 1.4
> 
>             ELSE 0
> 
>         END "UPDATED SALARY"
> 
> FROM employees;
> 
>   
> 
> --Example 2:
> 
> SELECT first_name, last_name, job_id, salary,
> 
>     CASE job_id
> 
>        WHEN 'ST_CLERK' THEN salary * 1.2
> 
>        WHEN 'SA_REP'   THEN salary * 1.3
> 
>        WHEN 'IT_PROG'  THEN salary * 1.4
> 
>        ELSE salary
> 
>     END "UPDATED SALARY"
> 
> FROM employees;
> 
>   
> 
> --Example 3:
> 
> SELECT first_name, last_name, job_id, salary,
> 
>     CASE
> 
>        WHEN job_id = 'ST_CLERK' THEN salary*1.2
> 
>        WHEN job_id = 'SA_REP'   THEN salary*1.3
> 
>        WHEN job_id = 'IT_PROG'  THEN salary*1.4
> 
>        ELSE salary
> 
>     END "UPDATED SALARY"
> 
> FROM employees;
> 
>   
> 
> --Example 4:
> 
> SELECT first_name, last_name, job_id, salary,
> 
>     CASE    WHEN job_id = 'ST_CLERK' THEN salary*1.2
> 
>             WHEN job_id = 'SA_REP'   THEN salary*1.3
> 
>             WHEN job_id = 'IT_PROG'  THEN salary*1.4
> 
>             WHEN last_name = 'King'  THEN 2*salary
> 
>             ELSE salary END "UPDATED SALARY"
> 
> FROM employees;
> 
>   
> 
> --Example 5:
> 
> SELECT first_name, last_name, job_id, salary,
> 
>     CASE    
> 
>        WHEN job_id = 'AD_PRES'  THEN salary*1.2
> 
>        WHEN job_id = 'SA_REP'   THEN salary*1.3
> 
>        WHEN job_id = 'IT_PROG'  THEN salary*1.4
> 
>        WHEN last_name = 'King'  THEN 2*salary
> 
>        ELSE salary
> 
>     END "UPDATED SALARY"
> 
> FROM employees;
> 
> --Example 6:
> 
>   
> 
> SELECT first_name, last_name, job_id, salary
> 
> FROM employees
> 
> WHERE (CASE
> 
>           WHEN job_id = 'IT_PROG' AND salary > 5000 THEN 1
> 
>           WHEN job_id = 'SA_MAN' AND salary > 10000 THEN 1
> 
>           ELSE 0
> 
>        END) = 1;
> ```

> [!INFO]- DECODE function
>The DECODE function transforms a value based on specified conditions and returns a corresponding result. If no condition is met, it returns either NULL or a provided default value, if specified.
> ```sql
> SELECT DECODE (1, 1,'One', 2,'Two') result FROM dual;
> 
>   
> 
> SELECT DECODE (25, 1,'One', 2,'Two',3,'Three','Not Found') result FROM dual;
> 
>   
> 
> SELECT first_name, last_name, job_id, salary,
> 
>        DECODE(job_id,'ST_CLERK',salary*1.20,
> 
>                      'SA_REP'  ,salary*1.30,
> 
>                      'IT_PROG' ,salary*1.50 ) as updated_salary
> 
> FROM EMPLOYEES;
> 
>   
> 
> SELECT first_name, last_name, job_id, salary,
> 
>        DECODE(job_id,'ST_CLERK', salary*1.20,
> 
>                      'SA_REP'  , salary*1.30,
> 
>                      'IT_PROG' , salary*1.50,
> 
>                       salary) as updated_salary
> 
> FROM EMPLOYEES;
> 
> ```

---

> [!info] Aggregation Functions
> Aggregation functions  are used to perform calculations on multiple rows and return a single result.
> - COUNT
> - SUM
> - AVG
> - MAX
> - MIN
> 


> [!caution] AVG does not include NULL values
> If you wish to include null values in the calculation, you can use the NVL() function. e.g: nvl(salary, 0) will convert all NULL values to 0.

>[!tip] COUNT can be used with the DISCTINCT operator to count non-repeated values

>[!tip] COUNT(\*) counts all rows while COUNT(column_name) counts only non-null values


> [!info]- `GROUP BY` Clause
> The `GROUP BY` clause is used to group rows with matching values in one or more columns. When using `GROUP BY`, all columns in the `SELECT` statement must either be included in the `GROUP BY` clause or be part of an aggregate function. `WHERE` clause can be used however, it filters the rows before the aggregation. If you wish to filter the aggregated rows, use the `HAVING` clause.
> ```sql
>
> SELECT avg(salary) FROM employees;
> 
> SELECT avg(salary) FROM employees WHERE job_id = 'IT_PROG';
> 
> SELECT job_id, avg(salary) FROM employees WHERE job_id = 'IT_PROG' or job_id = 'SA_REP' GROUP BY JOB_ID ORDER by 2 desc;
>
> SELECT job_id, avg(salary) FROM employees
>
> GROUP BY job_id;
> 
> SELECT job_id, avg(salary) FROM employees
> GROUP BY job_id
> ORDER BY avg(salary);
>
> SELECT job_id, avg(salary) FROM employees
>  GROUP BY job_id
>  ORDER BY avg(salary) DESC;
> 
>   
> 
> SELECT job_id, department_id, avg(salary) FROM employees
> 
> GROUP BY job_id, department_id;
> 
>   
> 
> SELECT job_id, department_id, avg(salary), count(*) FROM employees
> 
> GROUP BY job_id, department_id
> 
> ORDER BY count(*) DESC;
> 
>   
> 
> SELECT job_id, department_id, manager_id, avg(salary), count(*) FROM employees
> 
> GROUP BY job_id, department_id, manager_id
> 
> ORDER BY count(*) DESC;
> 
>   
> 
> SELECT job_id, department_id, avg(salary), count(*) FROM employees
> 
> GROUP BY department_id, job_id, manager_id;
> ```

> [!info]- `HAVING` Clause
> The `HAVING` clause is used to filter the aggregated columns
>```sql
 SELECT job_id, avg(salary) FROM employees
> GROUP BY job_id;
> 
>   
> -- will not work as you cannot filter using `WHERE` on aggregate columns
> SELECT job_id, avg(salary) FROM employees
> WHERE avg(salary) > 10000
> GROUP BY job_id;
> 
>   
> 
> SELECT job_id, avg(salary) FROM employees
> GROUP BY job_id
> HAVING avg(salary) > 10000;
> 
> SELECT job_id, avg(salary) FROM employees
> HAVING avg(salary) > 10000
> GROUP BY job_id;
> 
> 
> SELECT job_id, avg(salary) FROM employees
> WHERE hire_date > '28-MAY-05'
> GROUP BY job_id
> HAVING avg(salary) > 10000;
> 
> 
> SELECT job_id, avg(salary) FROM employees
> WHERE manager_id = 101
> GROUP BY job_id
> HAVING avg(salary) > 10000;
> 
> SELECT job_id, avg(salary) FROM employees
> WHERE salary > 5000
> GROUP BY job_id
> 
> --HAVING avg(salary) > 10000;
> 
> /
> 
> SELECT job_id, avg(salary) FROM employees
> --WHERE salary > 10000
> GROUP BY job_id
> HAVING avg(salary) > 5000;
> ```


---

==Constraints==

A constraint is a rule enforced on the data in a table. Constraints ensure the accuracy and integrity of the data by restricting the types of data that can be inserted into a table. Here’s a breakdown of the different types of constraints you might encounter in Oracle DB.
1. Primary Key Constraint (UNIQUE & NOT NULL)
2. Foreign Key Constraint
3. Unique Constraint
4. Not Null Constraint
5. Check Constraint

Constraints can be added during table creation or created and applied afterwards using table alteration. 

>[!tip] Constraint naming
>It's better to name your constraints to make them easily accessible in the future than to rely on default naming.
```sql title:"example of named and unnamed constraints"
CREATE TABLE managers

    (manager_id     NUMBER CONSTRAINT mgr_mid_uk UNIQUE,

     first_name     VARCHAR2(50),

     last_name      VARCHAR2(50),

     department_id  NUMBER NOT NULL,

     phone_number   VARCHAR2(11) UNIQUE NOT NULL,

     email          VARCHAR2(100),

     UNIQUE(email),

     CONSTRAINT mgr_composite_uq UNIQUE(department_id, first_name, last_name)

);
```

>[!note] composite unique constraint
>A **composite unique constraint** ensures that the combination of values across multiple columns in a table is unique, not the individual values within each column.


> [!INFO]- Creating Primary keys
>To create a simple primary key you can either add it directly to the column or add it as a constraint during table creation. However, composite primary keys must be created as a constraint.
> ```sql
> CREATE TABLE directors
>     (director_id   NUMBER CONSTRAINT dir_did_pk PRIMARY KEY,
> 
>      first_name    VARCHAR2(50),
> 
>      last_name     VARCHAR2(50)
> 
> );
> 
>   
> 
> CREATE TABLE executives
> 
>     (executive_id  NUMBER,
> 
>      first_name    VARCHAR2(50),
> 
>      last_name     VARCHAR2(50),
> 
>      CONSTRAINT dir_did_pk PRIMARY KEY (executive_id, last_name)
> 
> );
> ```

> [!INFO]- Creating foreign keys
> 
> ```sql
> CREATE TABLE managers
> 
>     (manager_id     NUMBER CONSTRAINT mgr_mid_uq UNIQUE,
> 
>      first_name     VARCHAR2(50),
> 
>      last_name      VARCHAR2(50),
> 
>      department_id  NUMBER NOT NULL,
> 
>      phone_number   VARCHAR2(11) UNIQUE NOT NULL,
> 
>      email      VARCHAR2(100),
> 
>      UNIQUE (email),
> 
>      CONSTRAINT mgr_emp_fk FOREIGN KEY (manager_id) REFERENCES employees_copy (employee_id),
> 
>      CONSTRAINT mgr_names_fk FOREIGN KEY (first_name, last_name) REFERENCES employees_copy(first_name, last_name)
> 
>      );
> ```

> [!INFO]- `CHECK` constraint
> The `CHECK` constraint ensures that the inserted data meets a certain criteria (is within a certain range, contains '.com' at the end of the string, etc....)
> ```sql
> CREATE TABLE managers2
> 
> (  
>     manager_id NUMBER,
>     first_name VARCHAR2(50),
>     salary     NUMBER,
>     CONSTRAINT salary_check CHECK (salary > 100 AND salary < 50000)
> );
>
> CREATE TABLE managers2 (
>     manager_id NUMBER,
>     first_name VARCHAR2(50),
>     salary NUMBER,
>     email VARCHAR2(100),
> 
>     CONSTRAINT demo_check CHECK (salary > 100 AND salary < 50000 AND upper(email) LIKE '%.COM')
> 
> );
> ```

> [!INFO]- Adding constraints using `ALTER TABLE`
> It is possible to add constraints after table creation
> >[!warning] When doing so, the existing data must be compliant with the newly added constraint.
> ```sql
> ALTER TABLE employees_copy ADD CONSTRAINT emp_cpy_names_uk UNIQUE (first_name, last_name);
> 
> ALTER TABLE employees_copy ADD UNIQUE (phone_number);
> 
> ALTER TABLE employees_copy ADD CHECK (salary > 10000);
> 
> ALTER TABLE employees_copy ADD CONSTRAINT emp_cpy_emp_id_pk PRIMARY KEY (employee_id);
> 
> ALTER TABLE employees_copy ADD CONSTRAINT emp_cpy_dept_fk FOREIGN KEY (department_id) REFERENCES departments(department_id);
> 
> ALTER TABLE employees_copy MODIFY salary CONSTRAINT emp_cpy_salary_nn NOT NULL;
> 
> ALTER TABLE employees_copy MODIFY last_name NOT NULL;
> 
> ALTER TABLE employees_copy MODIFY first_name NOT NULL;
> ```

> [!INFO] Dropping constraints
> This requires knowing the name of the constraint
> ```sql
> ALTER TABLE employees_copy DROP CONSTRAINT emp_cpy_emp_id_pk
> ```

> [!INFO] Renaming constraints
> ```sql
> ALTER TABLE employees_copy RENAME CONSTRAINT SYS_C008743 TO email_nn;
> ```
  
> [!INFO] Enabling and Disabling constraints
> It is also possible to add a disabled constraint
> 
> ```sql title:"disabling constraints"
> ALTER TABLE departments_copy
> DISABLE CONSTRAINT dept_cpy_id_pk;
> 
>   
> 
> ALTER TABLE departments_copy
> ADD CONSTRAINT dept_cpy_id_pk PRIMARY KEY (department_id) DISABLE;
> ```
> 
> ```sql title:"enabling constraints"
> ALTER TABLE departments_copy ENABLE CONSTRAINT dept_cpy_id_pk;
> ```



---
Joins

1. NATURAL JOIN
2. JOIN USING
3. JOIN ON
4. LEFT OUTER JOIN
5. RIGHT OUTER JOIN
6. FULL OUTER JOIN

>[!info] `NATURAL JOIN` 
>NATURAL JOIN operates on columns with identical names and data types to join two tables.
>>[!warning] `NATURAL` keyword cannot be omitted. 
>```sql
>SELECT * FROM employees NATURAL JOIN departments;
>```

> [!INFO] JOIN USING
> `USING` Clause allows you to specify which columns to use for the JOIN operation.
> >[!warning] `USING` requires the column names in both tables to match
> ```sql
> SELECT * FROM employees JOIN departments
> USING(department_id);
> 
>   
> SELECT * FROM employees JOIN departments
> USING(department_id, manager_id);
> ```

>[!warning] Ambiguous references to column names 
>To select a column that's present in both tables to be joined, you must disambiguate your selected column by prefixing it with a tablename 
>```sql
>SELECT first_name, last_name, department_name, manager_id FROM employees JOIN departments
>
USING(department_id);
>----fix:
>SELECT first_name, last_name, department_name, d.manager_id FROM employees e JOIN departments d
>USING(department_id);
>```




> [!INFO] JOIN ON (Natural Join)
> `ON` Clause provides more flexibility than `USING` as it allows you to select the exact columns in each table to use as join conditions. 
> >[!tip] The `INNER` keyword can be omitted.
> ```sql
> SELECT e.first_name, e.last_name, d.manager_id, d.department_name
> FROM employees e JOIN departments d
> 
> ON(e.department_id = d.department_id AND e.manager_id = d.manager_id);
>  
> SELECT e.first_name, e.last_name, d.manager_id, d.department_name
> FROM employees e INNER JOIN departments d
> 
> ON(e.department_id = d.department_id AND e.manager_id = d.manager_id);
> ```

> [!INFO] Restricting join results
> There are multiple ways to restrict such as using `WHERE` to filter rows after the join operation, but it would be more efficient filter using the `ON` clause.
> ```sql
> SELECT first_name, last_name, department_name, city, postal_code, street_address
> FROM employees e JOIN departments d
> ON(e.department_id = d.department_id)
> 
> AND e.job_id = 'IT_PROG';
> ```

>[!INFO] `OUTER JOIN`
>Outer joins return data from the outset of the intersection either left, right or both (full).
>>[!TIP] The keyword `OUTER` can be omitted.
>```sql
> SELECT e.first_name, e.last_name, d.department_id, d.department_name
> FROM employees e LEFT OUTER JOIN departments d
> 
> ON(e.department_id = d.department_id);
>```

